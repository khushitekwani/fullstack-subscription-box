### Integrating Stripe Payment Gateway: End-to-End Guide

I'll guide you through integrating Stripe as a payment gateway for your subscription box management system. This will involve changes to both the backend and frontend, as well as database schema modifications.

## 1. Database Schema Changes

First, let's update your database schema to support Stripe payments:

```sql
-- Add Stripe customer ID to user table
ALTER TABLE tbl_user
ADD COLUMN stripe_customer_id VARCHAR(255) NULL;

-- Update payment method enums
ALTER TABLE tbl_user_subscription
MODIFY COLUMN payment_method ENUM('cash', 'card', 'bank_transfer') DEFAULT 'card';

ALTER TABLE tbl_order
MODIFY COLUMN payment_method ENUM('cash', 'card', 'bank_transfer') DEFAULT 'card';

-- Create payment transactions table
CREATE TABLE tbl_payment_transaction (
    id BIGINT(20) PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT(20) NOT NULL,
    order_id BIGINT(20) NULL,
    subscription_id BIGINT(20) NULL,
    amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    payment_method ENUM('cash', 'card', 'bank_transfer') DEFAULT 'card',
    stripe_payment_intent_id VARCHAR(255) NULL,
    stripe_payment_method_id VARCHAR(255) NULL,
    status ENUM('pending', 'succeeded', 'failed', 'refunded') DEFAULT 'pending',
    error_message TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES tbl_user(id) ON DELETE CASCADE,
    FOREIGN KEY (order_id) REFERENCES tbl_order(id) ON DELETE SET NULL,
    FOREIGN KEY (subscription_id) REFERENCES tbl_user_subscription(id) ON DELETE SET NULL
);

-- Create customer payment methods table
CREATE TABLE tbl_customer_payment_method (
    id BIGINT(20) PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT(20) NOT NULL,
    stripe_payment_method_id VARCHAR(255) NOT NULL,
    card_brand VARCHAR(50) NULL,
    card_last4 VARCHAR(4) NULL,
    card_exp_month INT NULL,
    card_exp_year INT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES tbl_user(id) ON DELETE CASCADE
);
```

## 2. Backend Implementation

### 2.1 Install Required Packages

```shellscript
npm install stripe uuid
```

### 2.2 Configure Stripe in your backend

Create a new file `config/stripe.js`:

```javascript
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

module.exports = stripe;
```

### 2.3 Create Stripe Service

Create a new file `services/stripe_service.js`:

```javascript
const stripe = require('../config/stripe');
const pool = require('../config/database');
const util = require('util');
const query = util.promisify(pool.query).bind(pool);

class StripeService {
  // Create a Stripe customer
  async createCustomer(user) {
    try {
      const customer = await stripe.customers.create({
        email: user.email,
        name: user.name,
        phone: user.country_code + user.phone,
        metadata: {
          user_id: user.id
        }
      });

      // Update user with Stripe customer ID
      await query('UPDATE tbl_user SET stripe_customer_id = ? WHERE id = ?', [customer.id, user.id]);

      return customer;
    } catch (error) {
      console.error('Error creating Stripe customer:', error);
      throw error;
    }
  }

  // Get or create a Stripe customer
  async getOrCreateCustomer(userId) {
    try {
      // Check if user already has a Stripe customer ID
      const [user] = await query('SELECT * FROM tbl_user WHERE id = ?', [userId]);
      
      if (!user) {
        throw new Error('User not found');
      }

      if (user.stripe_customer_id) {
        // Retrieve the existing customer
        const customer = await stripe.customers.retrieve(user.stripe_customer_id);
        return customer;
      }

      // Create a new customer
      return await this.createCustomer(user);
    } catch (error) {
      console.error('Error getting or creating Stripe customer:', error);
      throw error;
    }
  }

  // Create a payment intent for a one-time payment
  async createPaymentIntent(userId, amount, currency = 'usd', metadata = {}) {
    try {
      const customer = await this.getOrCreateCustomer(userId);

      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency,
        customer: customer.id,
        metadata: {
          user_id: userId,
          ...metadata
        },
        setup_future_usage: 'off_session', // Allow reusing this payment method
      });

      return paymentIntent;
    } catch (error) {
      console.error('Error creating payment intent:', error);
      throw error;
    }
  }

  // Create a subscription
  async createSubscription(userId, planId, paymentMethodId) {
    try {
      // Get plan details
      const [plan] = await query('SELECT * FROM tbl_subscription_plans WHERE id = ?', [planId]);
      
      if (!plan) {
        throw new Error('Subscription plan not found');
      }

      // Get or create customer
      const customer = await this.getOrCreateCustomer(userId);

      // Attach payment method to customer
      await stripe.paymentMethods.attach(paymentMethodId, {
        customer: customer.id,
      });

      // Set as default payment method
      await stripe.customers.update(customer.id, {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });

      // Create a product in Stripe if it doesn't exist
      const [box] = await query('SELECT * FROM tbl_subscription_boxes WHERE id = ?', [plan.box_id]);
      
      let product;
      try {
        product = await stripe.products.retrieve(`box_${box.id}`);
      } catch (error) {
        product = await stripe.products.create({
          id: `box_${box.id}`,
          name: box.name,
          description: box.description,
          metadata: {
            box_id: box.id
          }
        });
      }

      // Create or retrieve price
      let price;
      try {
        price = await stripe.prices.retrieve(`plan_${plan.id}`);
      } catch (error) {
        price = await stripe.prices.create({
          id: `plan_${plan.id}`,
          product: product.id,
          unit_amount: Math.round(plan.price * 100), // Convert to cents
          currency: 'usd',
          recurring: {
            interval: plan.name === 'monthly' ? 'month' : 'quarter',
            interval_count: 1,
          },
          metadata: {
            plan_id: plan.id
          }
        });
      }

      // Create the subscription
      const subscription = await stripe.subscriptions.create({
        customer: customer.id,
        items: [
          {
            price: price.id,
          },
        ],
        payment_behavior: 'default_incomplete',
        payment_settings: {
          payment_method_types: ['card'],
          save_default_payment_method: 'on_subscription',
        },
        expand: ['latest_invoice.payment_intent'],
        metadata: {
          user_id: userId,
          plan_id: planId
        }
      });

      // Save payment method details
      const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
      if (paymentMethod.type === 'card') {
        await query(
          'INSERT INTO tbl_customer_payment_method (user_id, stripe_payment_method_id, card_brand, card_last4, card_exp_month, card_exp_year, is_default) VALUES (?, ?, ?, ?, ?, ?, ?)',
          [
            userId,
            paymentMethodId,
            paymentMethod.card.brand,
            paymentMethod.card.last4,
            paymentMethod.card.exp_month,
            paymentMethod.card.exp_year,
            true
          ]
        );
      }

      return subscription;
    } catch (error) {
      console.error('Error creating subscription:', error);
      throw error;
    }
  }

  // Cancel a subscription
  async cancelSubscription(stripeSubscriptionId) {
    try {
      return await stripe.subscriptions.cancel(stripeSubscriptionId);
    } catch (error) {
      console.error('Error canceling subscription:', error);
      throw error;
    }
  }

  // Get payment method details
  async getPaymentMethod(paymentMethodId) {
    try {
      return await stripe.paymentMethods.retrieve(paymentMethodId);
    } catch (error) {
      console.error('Error retrieving payment method:', error);
      throw error;
    }
  }

  // List customer's payment methods
  async listPaymentMethods(userId) {
    try {
      const [user] = await query('SELECT stripe_customer_id FROM tbl_user WHERE id = ?', [userId]);
      
      if (!user || !user.stripe_customer_id) {
        return [];
      }

      const paymentMethods = await stripe.paymentMethods.list({
        customer: user.stripe_customer_id,
        type: 'card',
      });

      return paymentMethods.data;
    } catch (error) {
      console.error('Error listing payment methods:', error);
      throw error;
    }
  }
}

module.exports = new StripeService();
```

### 2.4 Create Webhook Handler

Create a new file `controllers/webhook.js`:

```javascript
const stripe = require('../config/stripe');
const pool = require('../config/database');
const util = require('util');
const query = util.promisify(pool.query).bind(pool);
const common = require('../utilities/common');
const templates = require('../utilities/email_templates');
const responseCode = require('../utilities/response_code');
const response_message = require('../language/en');

class WebhookController {
  async handleWebhook(req, res) {
    const sig = req.headers['stripe-signature'];
    let event;

    try {
      event = stripe.webhooks.constructEvent(
        req.rawBody, // You need to access the raw body
        sig,
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.error(`Webhook Error: ${err.message}`);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    // Handle the event
    try {
      switch (event.type) {
        case 'payment_intent.succeeded':
          await this.handlePaymentIntentSucceeded(event.data.object);
          break;
        case 'payment_intent.payment_failed':
          await this.handlePaymentIntentFailed(event.data.object);
          break;
        case 'customer.subscription.created':
          await this.handleSubscriptionCreated(event.data.object);
          break;
        case 'customer.subscription.updated':
          await this.handleSubscriptionUpdated(event.data.object);
          break;
        case 'customer.subscription.deleted':
          await this.handleSubscriptionDeleted(event.data.object);
          break;
        case 'invoice.payment_succeeded':
          await this.handleInvoicePaymentSucceeded(event.data.object);
          break;
        case 'invoice.payment_failed':
          await this.handleInvoicePaymentFailed(event.data.object);
          break;
        default:
          console.log(`Unhandled event type ${event.type}`);
      }

      return res.json({ received: true });
    } catch (error) {
      console.error(`Error processing webhook: ${error.message}`);
      return res.status(500).send('Server error processing webhook');
    }
  }

  async handlePaymentIntentSucceeded(paymentIntent) {
    try {
      const userId = paymentIntent.metadata.user_id;
      const orderId = paymentIntent.metadata.order_id;
      
      if (orderId) {
        // Update order status
        await query('UPDATE tbl_order SET order_status = ? WHERE id = ?', ['pending', orderId]);
        
        // Record the transaction
        await query(
          'INSERT INTO tbl_payment_transaction (user_id, order_id, amount, currency, payment_method, stripe_payment_intent_id, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
          [
            userId,
            orderId,
            paymentIntent.amount / 100, // Convert from cents
            paymentIntent.currency,
            'card',
            paymentIntent.id,
            'succeeded'
          ]
        );

        // Send order confirmation email
        const [user] = await query('SELECT * FROM tbl_user WHERE id = ?', [userId]);
        const [order] = await query('SELECT * FROM tbl_order WHERE id = ?', [orderId]);
        
        if (user && order) {
          const subject = "Order Confirmation - Payment Received";
          const message = templates.payment_success({
            name: user.name,
            order_id: order.id,
            amount: order.grand_total,
            date: new Date().toLocaleDateString()
          });
          
          await common.sendMail(subject, user.email, message);
        }
      }
    } catch (error) {
      console.error('Error handling payment intent succeeded:', error);
      throw error;
    }
  }

  async handlePaymentIntentFailed(paymentIntent) {
    try {
      const userId = paymentIntent.metadata.user_id;
      const orderId = paymentIntent.metadata.order_id;
      
      if (orderId) {
        // Record the failed transaction
        await query(
          'INSERT INTO tbl_payment_transaction (user_id, order_id, amount, currency, payment_method, stripe_payment_intent_id, status, error_message) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
          [
            userId,
            orderId,
            paymentIntent.amount / 100, // Convert from cents
            paymentIntent.currency,
            'card',
            paymentIntent.id,
            'failed',
            paymentIntent.last_payment_error ? paymentIntent.last_payment_error.message : 'Payment failed'
          ]
        );

        // Send payment failed email
        const [user] = await query('SELECT * FROM tbl_user WHERE id = ?', [userId]);
        
        if (user) {
          const subject = "Payment Failed - Action Required";
          const message = templates.payment_failed({
            name: user.name,
            order_id: orderId,
            amount: paymentIntent.amount / 100,
            reason: paymentIntent.last_payment_error ? paymentIntent.last_payment_error.message : 'Payment failed'
          });
          
          await common.sendMail(subject, user.email, message);
        }
      }
    } catch (error) {
      console.error('Error handling payment intent failed:', error);
      throw error;
    }
  }

  async handleSubscriptionCreated(subscription) {
    try {
      const userId = subscription.metadata.user_id;
      const planId = subscription.metadata.plan_id;
      
      if (userId && planId) {
        // Get plan details
        const [plan] = await query('SELECT * FROM tbl_subscription_plans WHERE id = ?', [planId]);
        
        if (plan) {
          const startDate = new Date();
          const endDate = new Date();
          endDate.setMonth(endDate.getMonth() + plan.months);
          
          // Create subscription record
          const [result] = await query(
            'INSERT INTO tbl_user_subscription (user_id, plan_id, status, start_date, end_date, payment_method) VALUES (?, ?, ?, ?, ?, ?)',
            [
              userId,
              planId,
              subscription.status === 'active' ? 'active' : 'pending',
              startDate,
              endDate,
              'card'
            ]
          );
          
          const subscriptionId = result.insertId;
          
          // Update Stripe subscription with our subscription ID
          await stripe.subscriptions.update(subscription.id, {
            metadata: {
              ...subscription.metadata,
              subscription_id: subscriptionId
            }
          });
        }
      }
    } catch (error) {
      console.error('Error handling subscription created:', error);
      throw error;
    }
  }

  async handleSubscriptionUpdated(subscription) {
    try {
      const subscriptionId = subscription.metadata.subscription_id;
      
      if (subscriptionId) {
        let status;
        
        switch (subscription.status) {
          case 'active':
            status = 'active';
            break;
          case 'canceled':
            status = 'cancelled';
            break;
          case 'past_due':
          case 'unpaid':
            status = 'paused';
            break;
          default:
            status = 'active';
        }
        
        // Update subscription status
        await query('UPDATE tbl_user_subscription SET status = ? WHERE id = ?', [status, subscriptionId]);
        
        // Send notification email based on status change
        const [userSubscription] = await query(
          'SELECT us.*, u.email, u.name FROM tbl_user_subscription us JOIN tbl_user u ON us.user_id = u.id WHERE us.id = ?',
          [subscriptionId]
        );
        
        if (userSubscription) {
          let subject, message;
          
          if (status === 'active') {
            subject = "Your Subscription is Now Active";
            message = templates.subscription_active({
              name: userSubscription.name,
              subscription_id: subscriptionId
            });
          } else if (status === 'cancelled') {
            subject = "Your Subscription Has Been Cancelled";
            message = templates.subscription_cancelled({
              name: userSubscription.name,
              subscription_id: subscriptionId
            });
          } else if (status === 'paused') {
            subject = "Your Subscription Has Been Paused - Payment Required";
            message = templates.subscription_paused({
              name: userSubscription.name,
              subscription_id: subscriptionId
            });
          }
          
          if (subject && message) {
            await common.sendMail(subject, userSubscription.email, message);
          }
        }
      }
    } catch (error) {
      console.error('Error handling subscription updated:', error);
      throw error;
    }
  }

  async handleSubscriptionDeleted(subscription) {
    try {
      const subscriptionId = subscription.metadata.subscription_id;
      
      if (subscriptionId) {
        // Update subscription status to cancelled
        await query('UPDATE tbl_user_subscription SET status = ? WHERE id = ?', ['cancelled', subscriptionId]);
        
        // Send cancellation email
        const [userSubscription] = await query(
          'SELECT us.*, u.email, u.name FROM tbl_user_subscription us JOIN tbl_user u ON us.user_id = u.id WHERE us.id = ?',
          [subscriptionId]
        );
        
        if (userSubscription) {
          const subject = "Your Subscription Has Been Cancelled";
          const message = templates.subscription_cancelled({
            name: userSubscription.name,
            subscription_id: subscriptionId
          });
          
          await common.sendMail(subject, userSubscription.email, message);
        }
      }
    } catch (error) {
      console.error('Error handling subscription deleted:', error);
      throw error;
    }
  }

  async handleInvoicePaymentSucceeded(invoice) {
    try {
      const subscription = invoice.subscription;
      
      if (subscription) {
        const stripeSubscription = await stripe.subscriptions.retrieve(subscription);
        const subscriptionId = stripeSubscription.metadata.subscription_id;
        const userId = stripeSubscription.metadata.user_id;
        
        if (subscriptionId && userId) {
          // Record the transaction
          await query(
            'INSERT INTO tbl_payment_transaction (user_id, subscription_id, amount, currency, payment_method, stripe_payment_intent_id, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
            [
              userId,
              subscriptionId,
              invoice.amount_paid / 100, // Convert from cents
              invoice.currency,
              'card',
              invoice.payment_intent,
              'succeeded'
            ]
          );
          
          // Send payment success email
          const [user] = await query('SELECT * FROM tbl_user WHERE id = ?', [userId]);
          
          if (user) {
            const subject = "Subscription Payment Successful";
            const message = templates.subscription_payment_success({
              name: user.name,
              subscription_id: subscriptionId,
              amount: invoice.amount_paid / 100,
              date: new Date().toLocaleDateString()
            });
            
            await common.sendMail(subject, user.email, message);
          }
        }
      }
    } catch (error) {
      console.error('Error handling invoice payment succeeded:', error);
      throw error;
    }
  }

  async handleInvoicePaymentFailed(invoice) {
    try {
      const subscription = invoice.subscription;
      
      if (subscription) {
        const stripeSubscription = await stripe.subscriptions.retrieve(subscription);
        const subscriptionId = stripeSubscription.metadata.subscription_id;
        const userId = stripeSubscription.metadata.user_id;
        
        if (subscriptionId && userId) {
          // Record the failed transaction
          await query(
            'INSERT INTO tbl_payment_transaction (user_id, subscription_id, amount, currency, payment_method, stripe_payment_intent_id, status, error_message) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
            [
              userId,
              subscriptionId,
              invoice.amount_due / 100, // Convert from cents
              invoice.currency,
              'card',
              invoice.payment_intent,
              'failed',
              'Invoice payment failed'
            ]
          );
          
          // Send payment failed email
          const [user] = await query('SELECT * FROM tbl_user WHERE id = ?', [userId]);
          
          if (user) {
            const subject = "Subscription Payment Failed - Action Required";
            const message = templates.subscription_payment_failed({
              name: user.name,
              subscription_id: subscriptionId,
              amount: invoice.amount_due / 100,
              invoice_url: invoice.hosted_invoice_url
            });
            
            await common.sendMail(subject, user.email, message);
          }
        }
      }
    } catch (error) {
      console.error('Error handling invoice payment failed:', error);
      throw error;
    }
  }
}

module.exports = new WebhookController();
```

### 2.5 Update Subscription Model

Modify your existing `models/subscription_model.js` to integrate Stripe:

```javascript
// Add this at the top of the file
const stripeService = require('../services/stripe_service');

// Update the subscribeToBox method
subscribeToBox(req, res) {
  const user_id = req.user.id;
  const { plan_id, payment_method, address, payment_method_id } = req.body;

  // First check if plan exists
  const planQuery = `
    SELECT sp.*, sb.name as box_name 
    FROM tbl_subscription_plans sp
    JOIN tbl_subscription_boxes sb ON sp.box_id = sb.id
    WHERE sp.id = ? AND sp.is_deleted = 0 AND sp.is_active = 1
  `;

  pool.query(planQuery, [plan_id], async (error, result) => {
    if (error) {
      console.error("Database Query Error:", error);
      return common.response(res, {
        code: responseCode.OPERATION_FAILED,
        message: response_message.unsuccess,
        data: error.sqlMessage,
      });
    }

    if (result.length === 0) {
      return common.response(res, {
        code: responseCode.OPERATION_FAILED,
        message: response_message.subscription_plan_not_found,
        data: null,
      });
    }

    const plan = result[0];

    try {
      // Check if user already has an active subscription for this plan
      const activeSubscriptionQuery = `
        SELECT * FROM tbl_user_subscription 
        WHERE user_id = ? AND plan_id = ? AND status = 'active' AND is_deleted = 0
      `;

      pool.query(activeSubscriptionQuery, [user_id, plan_id], async (err, subscriptions) => {
        if (err) {
          console.error("Database Query Error:", err);
          return common.response(res, {
            code: responseCode.OPERATION_FAILED,
            message: response_message.unsuccess,
            data: err.sqlMessage,
          });
        }

        // If payment method is card, create a Stripe subscription
        if (payment_method === 'card' && payment_method_id) {
          try {
            const subscription = await stripeService.createSubscription(user_id, plan_id, payment_method_id);

            // Create order
            const orderData = {
              user_id,
              plan_id,
              address: address || "",
              payment_method,
              order_status: "pending",
              grand_total: plan.price,
              is_active: 1,
              is_deleted: 0,
            };

            pool.query("INSERT INTO tbl_order SET ?", orderData, (err, orderResult) => {
              if (err) {
                console.error("Database Query Error:", err);
                return common.response(res, {
                  code: responseCode.OPERATION_FAILED,
                  message: response_message.unsuccess,
                  data: err.sqlMessage,
                });
              }

              const order_id = orderResult.insertId;

              // Update the payment intent with the order ID
              if (subscription.latest_invoice && subscription.latest_invoice.payment_intent) {
                stripe.paymentIntents.update(subscription.latest_invoice.payment_intent.id, {
                  metadata: { order_id }
                });
              }

              return common.response(res, {
                code: responseCode.SUCCESS,
                message: response_message.subscription_created_successfully,
                data: {
                  subscription_id: subscription.id,
                  client_secret: subscription.latest_invoice.payment_intent.client_secret,
                  order_id,
                  plan_name: plan.name,
                  box_name: plan.box_name,
                  price: plan.price,
                },
              });
            });
          } catch (stripeError) {
            console.error("Stripe Error:", stripeError);
            return common.response(res, {
              code: responseCode.OPERATION_FAILED,
              message: stripeError.message || response_message.payment_failed,
              data: null,
            });
          }
        } else {
          // Handle cash or other payment methods as before
          const start_date = new Date();
          const end_date = new Date();
          end_date.setMonth(end_date.getMonth() + plan.months);

          // Create subscription
          const subscriptionData = {
            user_id,
            plan_id,
            status: "active",
            start_date,
            end_date,
            payment_method: payment_method || "cash",
            is_active: 1,
            is_deleted: 0,
          };

          pool.query("INSERT INTO tbl_user_subscription SET ?", subscriptionData, (err, subscriptionResult) => {
            if (err) {
              console.error("Database Query Error:", err);
              return common.response(res, {
                code: responseCode.OPERATION_FAILED,
                message: response_message.unsuccess,
                data: err.sqlMessage,
              });
            }

            const subscription_id = subscriptionResult.insertId;

            // Create order
            const orderData = {
              user_id,
              plan_id,
              address: address || "",
              payment_method: payment_method || "cash",
              order_status: "pending",
              grand_total: plan.price,
              is_active: 1,
              is_deleted: 0,
            };

            pool.query("INSERT INTO tbl_order SET ?", orderData, (err, orderResult) => {
              if (err) {
                console.error("Database Query Error:", err);
                return common.response(res, {
                  code: responseCode.OPERATION_FAILED,
                  message: response_message.unsuccess,
                  data: err.sqlMessage,
                });
              }

              const order_id = orderResult.insertId;

              return common.response(res, {
                code: responseCode.SUCCESS,
                message: response_message.subscription_created_successfully,
                data: {
                  subscription_id,
                  order_id,
                  plan_name: plan.name,
                  box_name: plan.box_name,
                  start_date,
                  end_date,
                  price: plan.price,
                },
              });
            });
          });
        }
      });
    } catch (err) {
      console.error("Error:", err);
      return common.response(res, {
        code: responseCode.OPERATION_FAILED,
        message: response_message.unsuccess,
        data: err.message,
      });
    }
  });
}

// Add a new method to cancel subscription
cancelSubscription(req, res) {
  const user_id = req.user.id;
  const { subscription_id } = req.params;

  // Verify subscription belongs to user
  const checkQuery = `
    SELECT us.*, sp.price, sp.name as plan_name, sb.name as box_name
    FROM tbl_user_subscription us
    JOIN tbl_subscription_plans sp ON us.plan_id = sp.id
    JOIN tbl_subscription_boxes sb ON sp.box_id = sb.id
    WHERE us.id = ? AND us.user_id = ? AND us.is_deleted = 0
  `;

  pool.query(checkQuery, [subscription_id, user_id], async (error, result) => {
    if (error) {
      console.error("Database Query Error:", error);
      return common.response(res, {
        code: responseCode.OPERATION_FAILED,
        message: response_message.unsuccess,
        data: error.sqlMessage,
      });
    }

    if (result.length === 0) {
      return common.response(res, {
        code: responseCode.OPERATION_FAILED,
        message: response_message.subscription_not_found,
        data: null,
      });
    }

    const subscription = result[0];

    // If payment method is card, cancel in Stripe
    if (subscription.payment_method === 'card') {
      try {
        // Find the Stripe subscription ID
        const [stripeSubscription] = await query(
          'SELECT * FROM tbl_payment_transaction WHERE subscription_id = ? ORDER BY created_at DESC LIMIT 1',
          [subscription_id]
        );

        if (stripeSubscription && stripeSubscription.stripe_payment_intent_id) {
          // Get the subscription from the payment intent
          const paymentIntent = await stripe.paymentIntents.retrieve(stripeSubscription.stripe_payment_intent_id);
          
          if (paymentIntent.metadata.subscription_id) {
            await stripeService.cancelSubscription(paymentIntent.metadata.subscription_id);
          }
        }
      } catch (stripeError) {
        console.error("Stripe Error:", stripeError);
        // Continue with local cancellation even if Stripe fails
      }
    }

    // Update subscription status
    const updateQuery = `
      UPDATE tbl_user_subscription 
      SET status = 'cancelled' 
      WHERE id = ?
    `;

    pool.query(updateQuery, [subscription_id], (err, updateResult) => {
      if (err) {
        console.error("Database Query Error:", err);
        return common.response(res, {
          code: responseCode.OPERATION_FAILED,
          message: response_message.unsuccess,
          data: err.sqlMessage,
        });
      }

      // Send cancellation email
      const [user] = await query('SELECT * FROM tbl_user WHERE id = ?', [user_id]);
      
      if (user) {
        const subject = "Your Subscription Has Been Cancelled";
        const message = templates.subscription_cancelled({
          name: user.name,
          subscription_id,
          plan_name: subscription.plan_name,
          box_name: subscription.box_name
        });
        
        common.sendMail(subject, user.email, message);
      }

      return common.response(res, {
        code: responseCode.SUCCESS,
        message: response_message.subscription_cancelled_successfully,
        data: { subscription_id, status: 'cancelled' },
      });
    });
  });
}

// Add a new method to get payment methods
getPaymentMethods(req, res) {
  const user_id = req.user.id;

  stripeService.listPaymentMethods(user_id)
    .then(paymentMethods => {
      return common.response(res, {
        code: responseCode.SUCCESS,
        message: response_message.success,
        data: paymentMethods,
      });
    })
    .catch(error => {
      console.error("Error fetching payment methods:", error);
      return common.response(res, {
        code: responseCode.OPERATION_FAILED,
        message: response_message.unsuccess,
        data: error.message,
      });
    });
}
```

### 2.6 Update Routes

Add new routes in `routers/routes.js`:

```javascript
// Add these routes to your existing routes
app.post("/v1/webhook", webhook.handleWebhook)
app.get("/v1/payment/methods", subscription.getPaymentMethods)
app.post("/v1/subscription/cancel/:subscription_id", subscription.cancelSubscription)
```

### 2.7 Create Email Templates for Payments

Add these templates to your email templates file:

```javascript
exports.payment_success = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Payment Successful</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Payment Successful</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>Your payment for order #${result.order_id} has been successfully processed.</p>
                      <p>Amount: $${result.amount}</p>
                      <p>Date: ${result.date}</p>
                      <p>Your order is now being processed and will be shipped soon.</p>
                      <p>Thank you for your purchase!</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};

exports.payment_failed = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Payment Failed</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Payment Failed</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>We were unable to process your payment for order #${result.order_id}.</p>
                      <p>Amount: $${result.amount}</p>
                      <p>Reason: ${result.reason}</p>
                      <p>Please update your payment information in your account settings and try again.</p>
                      <p>If you continue to experience issues, please contact our support team.</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};

exports.subscription_active = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Subscription Activated</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Subscription Activated</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>Your subscription #${result.subscription_id} is now active.</p>
                      <p>You can view your subscription details in your account dashboard.</p>
                      <p>Thank you for subscribing!</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};

exports.subscription_cancelled = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Subscription Cancelled</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Subscription Cancelled</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>Your subscription #${result.subscription_id} has been cancelled.</p>
                      <p>We're sorry to see you go. If you change your mind, you can always subscribe again.</p>
                      <p>Thank you for being a customer!</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};

exports.subscription_payment_success = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Subscription Payment Successful</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Subscription Payment Successful</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>Your payment for subscription #${result.subscription_id} has been successfully processed.</p>
                      <p>Amount: $${result.amount}</p>
                      <p>Date: ${result.date}</p>
                      <p>Your subscription is active and your next box will be shipped according to your subscription schedule.</p>
                      <p>Thank you for your continued subscription!</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};

exports.subscription_payment_failed = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Subscription Payment Failed</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Subscription Payment Failed</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>We were unable to process your payment for subscription #${result.subscription_id}.</p>
                      <p>Amount: $${result.amount}</p>
                      <p>Please update your payment information in your account settings or use the link below to pay your invoice:</p>
                      <p><a href="${result.invoice_url}" style="display: inline-block; padding: 10px 20px; background-color: #007BFF; color: white; text-decoration: none; border-radius: 5px;">Pay Invoice</a></p>
                      <p>If you continue to experience issues, please contact our support team.</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};

exports.subscription_paused = function (result) {
  const template = `<!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Subscription Paused</title>
  </head>
  <body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4;">
      <center>
          <table width="600" style="background-color: #ffffff; padding: 20px; border-radius: 5px;">
              <tr>
                  <td style="text-align: center;">
                      <h2 style="color: #333;">Subscription Paused</h2>
                      <p>Dear <strong>${result.name}</strong>,</p>
                      <p>Your subscription #${result.subscription_id} has been paused due to a payment issue.</p>
                      <p>Please update your payment information in your account settings to reactivate your subscription.</p>
                      <p>If you need assistance, please contact our support team.</p>
                      <p><strong>${globals.app_name} Team</strong></p>
                  </td>
              </tr>
          </table>
      </center>
  </body>
  </html>`;
  return template;
};
```

## 3. Frontend Implementation

### 3.1 Install Required Packages

```shellscript
npm install @stripe/stripe-js @stripe/react-stripe-js
```

### 3.2 Create Stripe Provider Component

Create a new file `src/components/StripeProvider.js`:

```javascriptreact
"use client"

import { Elements } from "@stripe/react-stripe-js"
import { loadStripe } from "@stripe/stripe-js"
import { useState, useEffect } from "react"

// Load Stripe outside of a component's render to avoid recreating the Stripe object on every render
const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY)

export default function StripeProvider({ children }) {
  const [clientSecret, setClientSecret] = useState("")

  useEffect(() => {
    // This is just to initialize Stripe with your account
    // You don't need to create a payment intent here
    // The actual payment intent will be created when the user subscribes
  }, [])

  const options = {
    clientSecret,
    appearance: {
      theme: "stripe",
      variables: {
        colorPrimary: "#4f46e5",
        colorBackground: "#ffffff",
        colorText: "#1f2937",
        colorDanger: "#ef4444",
        fontFamily: "Inter, system-ui, sans-serif",
        spacingUnit: "4px",
        borderRadius: "8px",
      },
    },
  }

  return (
    <Elements stripe={stripePromise} options={clientSecret ? options : undefined}>
      {children}
    </Elements>
  )
}
```

### 3.3 Update Root Layout

Update `src/app/layout.js` to include the Stripe provider:

```javascriptreact
import { Inter } from 'next/font/google'
import "./globals.css"
import Navbar from "@/components/Navbar"
import Footer from "@/components/Footer"
import StripeProvider from "@/components/StripeProvider"

const inter = Inter({ subsets: ["latin"] })

export const metadata = {
  title: "Subscription Box Management",
  description: "Browse and subscribe to premium subscription boxes",
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <StripeProvider>
          <div className="flex flex-col min-h-screen">
            <Navbar />
            <main className="flex-grow bg-gray-50">{children}</main>
            <Footer />
          </div>
        </StripeProvider>
      </body>
    </html>
  )
}
```

### 3.4 Create Payment Method Component

Create a new file `src/components/PaymentMethodForm.js`:

```javascriptreact
"use client"

import { useState } from "react"
import { CardElement, useStripe, useElements } from "@stripe/react-stripe-js"

export default function PaymentMethodForm({ onPaymentMethodCreated }) {
  const stripe = useStripe()
  const elements = useElements()
  const [error, setError] = useState(null)
  const [processing, setProcessing] = useState(false)

  const handleSubmit = async (event) => {
    event.preventDefault()
    setProcessing(true)

    if (!stripe || !elements) {
      setProcessing(false)
      return
    }

    const cardElement = elements.getElement(CardElement)

    const { error, paymentMethod } = await stripe.createPaymentMethod({
      type: "card",
      card: cardElement,
    })

    if (error) {
      setError(error.message)
      setProcessing(false)
    } else {
      onPaymentMethodCreated(paymentMethod)
      setProcessing(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="p-4 border border-gray-300 rounded-md">
        <CardElement
          options={{
            style: {
              base: {
                fontSize: "16px",
                color: "#424770",
                "::placeholder": {
                  color: "#aab7c4",
                },
              },
              invalid: {
                color: "#9e2146",
              },
            },
          }}
        />
      </div>

      {error && <div className="text-red-500 text-sm">{error}</div>}

      <button
        type="submit"
        disabled={!stripe || processing}
        className={`w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 ${
          (!stripe || processing) ? "opacity-70 cursor-not-allowed" : ""
        }`}
      >
        {processing ? "Processing..." : "Save Card"}
      </button>
    </form>
  )
}
```

### 3.5 Create Payment Methods Page

Create a new file `src/app/payment-methods/page.js`:

```javascriptreact
"use client"

import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"
import { API } from "@/api/apiHandler"
import { CreditCard, Plus, Trash } from 'lucide-react'
import PaymentMethodForm from "@/components/PaymentMethodForm"

export default function PaymentMethodsPage() {
  const router = useRouter()
  const [paymentMethods, setPaymentMethods] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  const [isAddingCard, setIsAddingCard] = useState(false)
  const [message, setMessage] = useState({ type: "", text: "" })

  useEffect(() => {
    fetchPaymentMethods()
  }, [])

  const fetchPaymentMethods = async () => {
    setLoading(true)
    try {
      const response = await API(null, "/v1/payment/methods", "GET")

      if (response.code === 1) {
        setPaymentMethods(response.data || [])
      } else {
        setError(response.message || "Failed to fetch payment methods")
      }
    } catch (err) {
      console.error("Error fetching payment methods:", err)
      setError("An error occurred while fetching your payment methods")
    } finally {
      setLoading(false)
    }
  }

  const handlePaymentMethodCreated = async (paymentMethod) => {
    try {
      // In a real implementation, you would send the payment method ID to your backend
      // to attach it to the customer
      // For now, we'll just add it to the list
      setPaymentMethods([...paymentMethods, paymentMethod])
      setIsAddingCard(false)
      setMessage({
        type: "success",
        text: "Payment method added successfully!",
      })
    } catch (err) {
      console.error("Error adding payment method:", err)
      setMessage({
        type: "error",
        text: "An error occurred while adding your payment method. Please try again.",
      })
    }
  }

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Payment Methods</h1>

      {message.text && (
        <div
          className={`p-4 rounded-md mb-6 ${
            message.type === "success" ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700"
          }`}
        >
          {message.text}
        </div>
      )}

      {error && <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6">{error}</div>}

      <div className="bg-white rounded-lg shadow-md p-6">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-semibold">Your Cards</h2>
          <button
            onClick={() => setIsAddingCard(!isAddingCard)}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 flex items-center"
          >
            {isAddingCard ? "Cancel" : <><Plus className="h-4 w-4 mr-1" /> Add New Card</>}
          </button>
        </div>

        {isAddingCard && (
          <div className="mb-6 p-4 border border-gray-200 rounded-md bg-gray-50">
            <h3 className="text-lg font-medium mb-4">Add New Card</h3>
            <PaymentMethodForm onPaymentMethodCreated={handlePaymentMethodCreated} />
          </div>
        )}

        {paymentMethods.length === 0 ? (
          <div className="text-center py-8">
            <CreditCard className="h-12 w-12 mx-auto text-gray-400 mb-4" />
            <p className="text-gray-500 mb-4">You don't have any saved payment methods yet.</p>
            {!isAddingCard && (
              <button
                onClick={() => setIsAddingCard(true)}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
              >
                Add a Card
              </button>
            )}
          </div>
        ) : (
          <div className="space-y-4">
            {paymentMethods.map((method) => (
              <div key={method.id} className="flex justify-between items-center p-4 border border-gray-200 rounded-md">
                <div className="flex items-center">
                  <CreditCard className="h-6 w-6 text-blue-500 mr-3" />
                  <div>
                    <p className="font-medium capitalize">
                      {method.card.brand}  {method.card.last4}
                    </p>
                    <p className="text-sm text-gray-500">
                      Expires {method.card.exp_month}/{method.card.exp_year}
                    </p>
                  </div>
                </div>
                <button className="text-red-500 hover:text-red-700">
                  <Trash className="h-5 w-5" />
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
```

### 3.6 Update Subscription Box Details Page

Update `src/app/subscription-boxes/[id]/page.js` to include Stripe payment:

```javascriptreact
"use client"

import { useState, useEffect } from "react"
import { useParams, useRouter } from "next/navigation"
import { API } from "@/api/apiHandler"
import { isUserLoggedIn } from "@/utils/auth"
import { CheckCircle, CreditCard } from 'lucide-react'
import { CardElement, useStripe, useElements } from "@stripe/react-stripe-js"

export default function SubscriptionBoxDetails() {
  const params = useParams()
  const router = useRouter()
  const stripe = useStripe()
  const elements = useElements()
  const { id } = params

  const [box, setBox] = useState(null)
  const [selectedPlan, setSelectedPlan] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  const [subscribing, setSubscribing] = useState(false)
  const [subscribeMessage, setSubscribeMessage] = useState({ type: "", text: "" })
  const [address, setAddress] = useState("")
  const [paymentMethod, setPaymentMethod] = useState("card")
  const [cardError, setCardError] = useState(null)
  const [clientSecret, setClientSecret] = useState("")
  const [subscription, setSubscription] = useState(null)
  const [paymentStatus, setPaymentStatus] = useState("initial") // initial, processing, succeeded, failed

  useEffect(() => {
    fetchBoxDetails()
  }, [id])

  const fetchBoxDetails = async () => {
    setLoading(true)
    try {
      const response = await API(null, `/v1/subscription/box/${id}`, "GET")

      if (response.code === 1) {
        setBox(response.data)
        // Set the first plan as selected by default if available
        if (response.data?.plans && response.data.plans.length > 0) {
          setSelectedPlan(response.data.plans[0])
        }
      } else {
        setError(response.message || "Failed to fetch subscription box details")
      }
    } catch (err) {
      console.error("Error fetching box details:", err)
      setError("An error occurred while fetching subscription box details")
    } finally {
      setLoading(false)
    }
  }

  const handlePlanSelect = (plan) => {
    setSelectedPlan(plan)
  }

  const handlePaymentMethodChange = (e) => {
    setPaymentMethod(e.target.value)
  }

  const handleSubscribe = async () => {
    if (!isUserLoggedIn()) {
      router.push("/login?redirect=subscription-boxes/" + id)
      return
    }

    if (!selectedPlan) {
      setSubscribeMessage({ type: "error", text: "Please select a subscription plan" })
      return
    }

    if (paymentMethod === "card" && !stripe) {
      setSubscribeMessage({ type: "error", text: "Stripe is not loaded yet. Please try again." })
      return
    }

    setSubscribing(true)
    setSubscribeMessage({ type: "", text: "" })

    try {
      if (paymentMethod === "card") {
        // Create a payment method
        const cardElement = elements.getElement(CardElement)
        
        if (!cardElement) {
          setSubscribeMessage({ type: "error", text: "Card element not found. Please refresh and try again." })
          setSubscribing(false)
          return
        }

        const { error, paymentMethod } = await stripe.createPaymentMethod({
          type: "card",
          card: cardElement,
        })

        if (error) {
          setCardError(error.message)
          setSubscribing(false)
          return
        }

        // Subscribe with the payment method
        const response = await API(
          {
            plan_id: selectedPlan.id,
            payment_method: "card",
            payment_method_id: paymentMethod.id,
            address,
          },
          "/v1/subscription/subscribe",
          "POST",
        )

        if (response.code === 1) {
          setSubscription(response.data)
          setClientSecret(response.data.client_secret)
          setPaymentStatus("processing")

          // Confirm the payment
          const { error: confirmError } = await stripe.confirmCardPayment(response.data.client_secret)

          if (confirmError) {
            setPaymentStatus("failed")
            setSubscribeMessage({
              type: "error",
              text: confirmError.message || "Payment failed. Please try again.",
            })
          } else {
            setPaymentStatus("succeeded")
            setSubscribeMessage({
              type: "success",
              text: "Successfully subscribed to the box! Your first delivery is on the way.",
            })

            // Redirect to subscriptions page after a delay
            setTimeout(() => {
              router.push("/subscriptions")
            }, 2000)
          }
        } else {
          setSubscribeMessage({
            type: "error",
            text: response.message || "Failed to subscribe to the box. Please try again.",
          })
        }
      } else {
        // Handle cash payment as before
        const response = await API(
          {
            plan_id: selectedPlan.id,
            payment_method: "cash",
            address,
          },
          "/v1/subscription/subscribe",
          "POST",
        )

        if (response.code === 1) {
          setSubscribeMessage({
            type: "success",
            text: "Successfully subscribed to the box! Your first delivery is on the way.",
          })

          // Redirect to subscriptions page after a delay
          setTimeout(() => {
            router.push("/subscriptions")
          }, 2000)
        } else {
          setSubscribeMessage({
            type: "error",
            text: response.message || "Failed to subscribe to the box. Please try again.",
          })
        }
      }
    } catch (err) {
      console.error("Error subscribing:", err)
      setSubscribeMessage({
        type: "error",
        text: "An error occurred while processing your subscription. Please try again.",
      })
    } finally {
      setSubscribing(false)
    }
  }

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">{error}</div>
      </div>
    )
  }

  if (!box) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center py-12">
          <p className="text-gray-500 text-lg">Subscription box not found.</p>
        </div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="bg-white rounded-lg shadow-md overflow-hidden">
        <div className="p-6">
          <h1 className="text-3xl font-bold mb-2">{box.name}</h1>
          <p className="text-gray-600 mb-6">{box.description}</p>

          <div className="mb-8">
            <h2 className="text-xl font-semibold mb-4">Choose Your Subscription Plan</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {box.plans.map((plan) => (
                <div
                  key={plan.id}
                  className={`border rounded-lg p-4 cursor-pointer transition-all ${
                    selectedPlan?.id === plan.id
                      ? "border-blue-500 bg-blue-50"
                      : "border-gray-200 hover:border-blue-300"
                  }`}
                  onClick={() => handlePlanSelect(plan)}
                >
                  <div className="flex justify-between items-center">
                    <div>
                      <h3 className="font-semibold text-lg capitalize">{plan.name}</h3>
                      <p className="text-gray-600">
                        {plan.months} {plan.months === 1 ? "month" : "months"}
                      </p>
                    </div>
                    <div className="text-xl font-bold">${plan.price}</div>
                  </div>
                  {plan.products && plan.products.length > 0 && (
                    <div className="mt-3 pt-3 border-t">
                      <p className="text-sm text-gray-700">Includes:</p>
                      <ul className="mt-1">
                        {plan.products.map((product) => (
                          <li key={product.id} className="flex items-center text-sm">
                            <CheckCircle className="h-4 w-4 text-green-500 mr-2" />
                            {product.name}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>

          <div className="mb-6">
            <h2 className="text-xl font-semibold mb-4">Payment Method</h2>
            <div className="space-y-4">
              <div className="flex items-center space-x-3">
                <input
                  type="radio"
                  id="card"
                  name="paymentMethod"
                  value="card"
                  checked={paymentMethod === "card"}
                  onChange={handlePaymentMethodChange}
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500"
                />
                <label htmlFor="card" className="flex items-center">
                  <CreditCard className="h-5 w-5 text-blue-500 mr-2" />
                  <span>Credit/Debit Card</span>
                </label>
              </div>

              <div className="flex items-center space-x-3">
                <input
                  type="radio"
                  id="cash"
                  name="paymentMethod"
                  value="cash"
                  checked={paymentMethod === "cash"}
                  onChange={handlePaymentMethodChange}
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500"
                />
                <label htmlFor="cash">Cash on Delivery</label>
              </div>

              {paymentMethod === "card" && (
                <div className="mt-4 p-4 border border-gray-300 rounded-md">
                  <CardElement
                    options={{
                      style: {
                        base: {
                          fontSize: "16px",
                          color: "#424770",
                          "::placeholder": {
                            color: "#aab7c4",
                          },
                        },
                        invalid: {
                          color: "#9e2146",
                        },
                      },
                    }}
                  />
                  {cardError && <div className="text-red-500 text-sm mt-2">{cardError}</div>}
                </div>
              )}
            </div>
          </div>

          <div className="mb-6">
            <h2 className="text-xl font-semibold mb-4">Shipping Address</h2>
            <textarea
              value={address}
              onChange={(e) => setAddress(e.target.value)}
              placeholder="Enter your shipping address"
              className="w-full p-3 border border-gray-300 rounded-md"
              rows={3}
            />
          </div>

          {subscribeMessage.text && (
            <div
              className={`p-4 rounded-md mb-6 ${
                subscribeMessage.type === "success" ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700"
              }`}
            >
              {subscribeMessage.text}
            </div>
          )}

          <div className="flex justify-between items-center">
            <button
              onClick={() => router.back()}
              className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50"
            >
              Back
            </button>
            <button
              onClick={handleSubscribe}
              disabled={subscribing || !selectedPlan || (paymentMethod === "card" && !stripe)}
              className={`px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 ${
                subscribing || !selectedPlan || (paymentMethod === "card" && !stripe)
                  ? "opacity-70 cursor-not-allowed"
                  : ""
              }`}
            >
              {subscribing ? "Processing..." : `Subscribe for $${selectedPlan?.price || 0}`}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
```

### 3.7 Update Subscriptions Page

Update `src/app/subscriptions/page.js` to handle subscription cancellation:

```javascriptreact
"use client"

import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"
import { API } from "@/api/apiHandler"
import { Package, Calendar, Clock, AlertTriangle, DollarSign } from 'lucide-react'

export default function SubscriptionsPage() {
  const router = useRouter()
  const [subscriptions, setSubscriptions] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  const [cancellingId, setCancellingId] = useState(null)
  const [message, setMessage] = useState({ type: "", text: "" })

  useEffect(() => {
    fetchSubscriptions()
  }, [])

  const fetchSubscriptions = async () => {
    setLoading(true)
    try {
      const response = await API(null, "/v1/subscription/user/subscriptions", "GET")

      if (response.code === 1) {
        setSubscriptions(response.data || [])
      } else {
        setError(response.message || "Failed to fetch subscriptions")
      }
    } catch (err) {
      console.error("Error fetching subscriptions:", err)
      setError("An error occurred while fetching your subscriptions")
    } finally {
      setLoading(false)
    }
  }

  const handleCancelSubscription = async (id) => {
    setCancellingId(id)
    setMessage({ type: "", text: "" })

    try {
      const response = await API(null, `/v1/subscription/cancel/${id}`, "POST")

      if (response.code === 1) {
        setMessage({
          type: "success",
          text: "Subscription cancelled successfully. Any upcoming renewals have been cancelled.",
        })
        // Refresh subscriptions
        fetchSubscriptions()
      } else {
        setMessage({
          type: "error",
          text: response.message || "Failed to cancel subscription. Please try again.",
        })
      }
    } catch (err) {
      console.error("Error cancelling subscription:", err)
      setMessage({
        type: "error",
        text: "An error occurred while cancelling your subscription. Please try again.",
      })
    } finally {
      setCancellingId(null)
    }
  }

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">My Subscriptions</h1>

      {error && <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6">{error}</div>}

      {message.text && (
        <div
          className={`p-4 rounded-md mb-6 ${
            message.type === "success" ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700"
          }`}
        >
          {message.text}
        </div>
      )}

      {subscriptions.length === 0 ? (
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <Package className="h-12 w-12 mx-auto text-gray-400 mb-4" />
          <h2 className="text-xl font-semibold mb-2">No Active Subscriptions</h2>
          <p className="text-gray-600 mb-4">You don't have any active subscriptions yet.</p>
          <button
            onClick={() => router.push("/subscription-boxes")}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Browse Subscription Boxes
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {subscriptions.map((subscription) => (
            <div key={subscription.id} className="bg-white rounded-lg shadow-md overflow-hidden">
              <div className="p-6">
                <div className="flex justify-between items-start mb-4">
                  <h2 className="text-xl font-bold">{subscription.box_name}</h2>
                  <div
                    className={`px-3 py-1 rounded-full text-sm font-medium ${
                      subscription.status === "active"
                        ? "bg-green-100 text-green-800"
                        : subscription.status === "paused"
                          ? "bg-yellow-100 text-yellow-800"
                          : "bg-red-100 text-red-800"
                    }`}
                  >
                    {subscription.status.charAt(0).toUpperCase() + subscription.status.slice(1)}
                  </div>
                </div>

                <p className="text-gray-600 mb-4 line-clamp-2">{subscription.description}</p>

                <div className="grid grid-cols-2 gap-3 mb-4">
                  <div className="flex items-center">
                    <Calendar className="h-5 w-5 text-blue-500 mr-2" />
                    <div>
                      <p className="text-sm text-gray-500">Plan</p>
                      <p className="font-medium capitalize">{subscription.plan_name}</p>
                    </div>
                  </div>
                  <div className="flex items-center">
                    <DollarSign className="h-5 w-5 text-green-500 mr-2" />
                    <div>
                      <p className="text-sm text-gray-500">Price</p>
                      <p className="font-medium">${subscription.price}</p>
                    </div>
                  </div>
                  <div className="flex items-center">
                    <Clock className="h-5 w-5 text-purple-500 mr-2" />
                    <div>
                      <p className="text-sm text-gray-500">Started</p>
                      <p className="font-medium">{new Date(subscription.start_date).toLocaleDateString()}</p>
                    </div>
                  </div>
                  <div className="flex items-center">
                    <Clock className="h-5 w-5 text-orange-500 mr-2" />
                    <div>
                      <p className="text-sm text-gray-500">Renews</p>
                      <p className="font-medium">{new Date(subscription.end_date).toLocaleDateString()}</p>
                    </div>
                  </div>
                </div>

                <div className="flex items-center text-sm text-gray-500 mb-4">
                  <span className="capitalize mr-1">Payment Method:</span>
                  <span className="font-medium capitalize">{subscription.payment_method}</span>
                </div>

                {subscription.status === "active" && (
                  <div className="mt-4 pt-4 border-t">
                    <button
                      onClick={() => handleCancelSubscription(subscription.id)}
                      disabled={cancellingId === subscription.id}
                      className={`flex items-center text-red-600 hover:text-red-800 ${
                        cancellingId === subscription.id ? "opacity-70 cursor-not-allowed" : ""
                      }`}
                    >
                      <AlertTriangle className="h-4 w-4 mr-1" />
                      {cancellingId === subscription.id ? "Cancelling..." : "Cancel Subscription"}
                    </button>
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

### 3.8 Update Navbar to Include Payment Methods Link

Update `src/components/Navbar.js` to include a link to payment methods:

```javascriptreact
// Add this to the user protected routes section
<Link
  href="/payment-methods"
  className={`inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium ${
    pathname === "/payment-methods"
      ? "border-blue-500 text-gray-900"
      : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
  }`}
>
  Payment Methods
</Link>
```

## 4. Environment Variables

Create a `.env` file with the following variables:

```plaintext
# Stripe API Keys
STRIPE_SECRET_KEY=sk_test_your_stripe_secret_key
STRIPE_WEBHOOK_SECRET=whsec_your_stripe_webhook_secret
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_your_stripe_publishable_key

# Database
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=your_database_name

# Email
mailer_email=your_email@gmail.com
mailer_password=your_app_password
```

## 5. Setting Up Stripe Webhooks

1. Install the Stripe CLI from [https://stripe.com/docs/stripe-cli](https://stripe.com/docs/stripe-cli)
2. Login to your Stripe account:

```shellscript
stripe login
```


3. Start listening for webhooks:

```shellscript
stripe listen --forward-to https://subscription-management-pw3f.onrender.com/v1/webhook
```


4. The CLI will provide a webhook signing secret. Add this to your `.env` file as `STRIPE_WEBHOOK_SECRET`.


## 6. Testing the Integration

1. Start your backend server:

```shellscript
npm start
```


2. Start your frontend server:

```shellscript
npm run dev
```


3. Open your browser and navigate to `https://subscription-management-pw3f.onrender.com`
4. Test the subscription flow with Stripe's test cards:

1. Use `4242 4242 4242 4242` for successful payments
2. Use `4000 0000 0000 0002` for declined payments
3. Use any future date for expiry and any 3-digit CVC





## 7. Deployment Considerations

1. **SSL**: Ensure your production environment uses HTTPS, as Stripe requires secure connections.
2. **Webhooks**: Update your webhook endpoint in the Stripe dashboard to point to your production URL.
3. **Environment Variables**: Make sure all environment variables are properly set in your production environment.
4. **Error Handling**: Implement more robust error handling and logging in production.


## 8. Troubleshooting

1. **Payment Failures**: Check the Stripe dashboard for detailed error messages.
2. **Webhook Issues**: Verify the webhook signing secret is correct and that your server can receive POST requests.
3. **Database Errors**: Ensure your database schema has been updated correctly.
4. **Frontend Errors**: Check the browser console for any JavaScript errors.


This comprehensive guide should help you integrate Stripe payments into your subscription box management system. The implementation includes both one-time payments and recurring subscriptions, with proper handling of payment success and failure scenarios.